[toc]

## 资源管理

概述：资源管理是 C++ 程序最需要注意的问题。而其中最常使用的资源便是**动态内存**，很大一部分
C++ 程序错误的原因就是因为内存分配中的**野指针**问题。其它常见资源包括：文件描述器，互斥锁，图形界面的字形和笔刷，数据库连接，以及网络 sockets。

### - 利用**RAII**思想——使用资源管理类管理资源

- 设计一个管理类。获取资源后立即放进管理对象内。在管理对象运用析构函数确保资源释放。

> 一个常用的技巧是，使用智能指针管理所需资源

### - 小心复制行为 of 资源管理类

- 除非必要，禁止复制
- 对底层资源采用“引用计数法”（即尽可能采用智能指针）
- 若需要复制底部资源，则对资源进行深拷贝
- 可以选择——转移底部资源的拥有权

### - 提供 API 访问底层资源

### - 小心使用 new 和 delete

- 成对使用 new 和 delete。

    > 1. new，delete
    >
    > 2. new []，delete []

- **注意 new 会抛出异常**，请留意异常规范

- 以独立语句将 new 放入智能指针**（新 c++ 尽量使用 make_shared 函数家族）**

考虑以下行为，我们定义了一个 process 函数，它接受一个智能指针和一个 int 值。

~~~c++
void process(std::shared_ptr<int> pw, int priority);
//而后我们这样调用它，priority 函数返回一个 int 值。
process(std::shared_ptr<int>(new int(10)), priority());
~~~

在调用 process 函数之前，**①std::shared_ptr 的构造函数，②new 分配内存，③priority 函数**会被执行，但是**他们之间的执行顺序是未知的**，只有一个可以肯定，那就是 new 分配内存会在①之前。

考虑以下执行顺序：

```txt
1. 执行 new；
2. 调用 priority；
3. 调用 std::shared_ptr 构造函数。
```

如果在调用 priority 时发生异常，new 返回的指针将会丢失，因为它尚未被置入智能指针内，这会引起资源泄露。

- delete 的过程

```text
1. 调用析构函数
2. 调用 operator delete
3. free
```



