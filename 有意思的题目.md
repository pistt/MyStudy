[TOC]

## [我的力扣练习](https://leetcode-cn.com/u/xrui-f/)

## 有意思的题目

### N 个数，范围为$10^{18}$，找到 N 个数中间距最大的两个数，要求O(N)

例如：100，10 之间间距就为 90。

思路：N个数中根据 (min, max) 的范围，分成 N + 1 个桶，那么肯定会有至少一个桶空。空桶左右两个桶的最大最小差即为答案。有多个空桶时，比较多个最大最小差即可。



### N 人过桥问题

**只有两种策略可以最优**

1. 最快的人分别带最慢和次慢的人过桥`cost[n]+cost[n-1]+cost[1]*2`
2. 最快的2人先过桥，最快的送回手电筒，然后最慢的2人过桥，次快的送回手电筒`cost[n]+cost[1]+cost[2]*2`



### 找毒水

> 1000 瓶水其中有 1 瓶水有毒，有 10 只老鼠并且只要老鼠喝了有毒的水必死。
>
> 请问怎样通过一次实验找出有毒的那瓶水。
>
> [Leetcode 458](https://leetcode-cn.com/problems/poor-pigs/)

**第一种：基础**

解题思路：**二进制。**

第一步：2的10次方等于1024，1000 <= 1024。只需要用二进制为每瓶水编码，每只老鼠代表一个二进制位，

| 第9位 | 第8位 | 第7位 | 第6位 | 第5位 | 第4位 | 第3位 | 第2位 | 第1位 | 第0位 | 水编号  |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :-----: |
|   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |  **0**  |
|   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   1   |  **1**  |
|   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   1   |   0   |  **2**  |
|  ...  |  ...  |  ...  |  ...  |  ...  |  ...  |  ...  |  ...  |  ...  |  ...  |   ...   |
|   1   |   1   |   1   |   1   |   1   |   0   |   0   |   1   |   1   |   0   | **998** |
|   1   |   1   |   1   |   1   |   1   |   0   |   0   |   1   |   1   |   1   | **999** |

第二步：将10只老鼠从mouse[0]到mouse[9]进行编号

0.让第mouse[0]只老鼠喝第0位为1的所有的水

1.让第mouse[1]只老鼠喝第1位为1的所有的水

2.让第mouse[2]只老鼠喝第2位为1的所有的水

…………

**第二种变体：服用后一小时毒发，那么两小时内用几只小白鼠能够找出毒药？**

​	两个小时就可以测试两轮，且第一轮死了的小白鼠不能参与第二轮，可以用3进制。

​		0表示两轮都不喝

　　1表示第一轮喝，第二轮不喝

　　2表示第一轮不喝，第二轮喝

　　00=0

　　01=1

　　02=2

　　10=3

　　11=4

　　12=5

　　20=6

　　21=7

　　如果鼠1第二轮死，鼠二第一轮死，就是12=5

- **结论：最后推出公式为（测试次数+1）^x >= 药水瓶数   x为白鼠数量  求x的最小整数值**



**第三种变体：有16瓶水1瓶有毒，用多少只小白鼠能测出14瓶无毒的水？**

　将16瓶药水用二进制XXXX表示，取3只小白鼠来测，测出的状态为XXX，那么毒在XXX0或XXX1中，剩下14瓶无毒。



### 大于等于 N 的下一个 2 的幂次

```c++
int nextPowerOf2(int n) {
	n -= 1;
    n |= n >> 16;
    n |= n >> 8;
    n |= n >> 4;
    n |= n >> 2;
    n |= n >> 1;
    return n + 1;
}
```





### 元素重复三次的数组中查找仅出现一次的元素

[Leetcode 137. 只出现一次的数字](https://leetcode-cn.com/problems/single-number-ii/)：更多做法可以看官方题解，直接模三统计并或运算。每一位 直接ans & 1 统计数目，再模三。

<strong>题目大意：</strong>
给定一个大数组，它里面除了一个元素外，其他元素都重复了三次，要求在**空间复杂度为O（1）**, **时间复杂度为O（n）**的约束下，查找到只重复了一次的元素。



<strong>解题思路：</strong>因为元素都重复三次，因此我们可以考虑统计元素出现的次数，一旦元素出现了三次，重新置零。一般做法是通过 hash-map 的方法实现上述思路，但是空间复杂度为 O(n)。实际上分析可以知道，重复数据的比特位会重复出现，那么我们可以统计比特位出现的次数代替之。



**模三加法，统计数据中每个比特位 1 出现的次数。用一个 3 进制计数器去模拟，出现 0 次为 00，出现 1 次为 01， 出现 2 次为 10， 出现 3 次因进位重置为 00.** 通过一个模三加法，当某一个 1 比特位重复出现 3 次时，我们就可以把他消去。参考加法器的性质和逻辑，**低位存储的即是出现 1 次的比特位，高位存储的即是出现 2 次的比特位。**

> 因为 0 比特并不携带信息（或者说 0 代表没有，所以不会影响状态）

- 考虑数据元素的比特位，即输入比特位，称之为 A。和一个三进制加法器，高位为 B，低位为 C。
- 参考 加法器（时序电路）的设计方式，我们可以得到以下表格。$B^{n}\text{ 和 }C^{n}$ 为加法器当前状态，而 n+1 则为加法器根据输入 A 和 当前状态 需要转移到的状态。

![时序电路](.\images\时序电路.png)

由上图我们可以得到一个逻辑表达式：
（事实上，由于 BC 取值为 11 的情况不用，可以增加冗余项化简下面某些逻辑表达式）

**根据 2个旧状态 的时序逻辑表达式为：**

- $$B^{n+1}=\overline{A}\cdot B^{n}\cdot\overline{C^{n}}+A\cdot \overline{B^{n}}\cdot C^{n}\hspace{30mm}(1)$$
- $$C^{n+1}=\overline{A}\cdot \overline{B^{n}}\cdot C^{n} + A\cdot \overline{B^{n}} \cdot\overline{C^{n}}\\  \hspace{8.8mm}=\overline{B^{n}}\cdot (A \oplus C^{n})\hspace{49.5mm}(2)$$

**根据 1个旧状态 和 1个新状态 的时序逻辑表达式为：**

- $$B^{n+1}=\overline{A}\cdot B^{n}\cdot\overline{C^{n+1}}+A\cdot \overline{B^{n}}\cdot \overline{C^{n+1}}\\ \hspace{8.8mm}=\overline{C^{n+1}}\cdot (A\oplus B^{n})\hspace{46mm}(3)$$

- $$C^{n+1}=\overline{A}\cdot \overline{B^{n+1}}\cdot \overline{C^{n}} + A\cdot \overline{B^{n+1}}\cdot \overline{C^{n}}\\ \hspace{8.8mm}=\overline{B^{n+1}}\cdot \overline{C^{n}}\hspace{57mm}(4)$$

实际上，由于程序是顺序执行，我们更新 B 和 C 的时候， 其中一个已经变成了新状态，具体取决于程序先更新的是哪个。所以我们需要组合使用 (1) (4) 或者 (2) (3) 。伪代码可以这样表示：

~~~c++
//compose (1) (4), update
B = ~A & B & ~C | A & ~B & C	//(1)
C = ~B & ~C						//(4)
    
//compose (2) (3), udate
C = ~B & A ^ C					//(2)
B = ~C & A ^ B					//(3)
~~~

至此，题目得到解决，C 即是所求答案。若寻找重复出现 2 次的元素，B 即是答案。

> 另外的解法：剑指offer DFA



## 一个半径为 r~1~ 的圆表面能黏多少半径为 r~2~ 的圆？

<img src=".\images\微信截图_20210502224324.png" alt="微信截图_20210502224324" style="zoom:50%;"/>

由余弦定理，$cos(\alpha)=\dfrac{AB^{2}+AC^{2}-BC^{2}}{2\cdot AB\cdot AC}=\dfrac{2(r_{1}+r_{2})^{2}-(2 r_{2})^{2}}{2 \cdot (r_{1}+r_{2})^2}=1-\dfrac{2 r_{2}^{2}}{(r_{1}+r_{2})^{2}}$ 

即有 $\alpha =cos^{-1}\alpha = arccos(1-\dfrac{2 r_{2}^{2}}{(r_{1}+r_{2})^{2}})$

则表面能粘合的圆数目为$count = \lfloor\dfrac{2\pi}{\alpha}\rfloor $

